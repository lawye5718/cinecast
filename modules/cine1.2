è¿™æ˜¯ä¸€æ¬¡éå¸¸æ·±åº¦çš„æ¶æ„æ¼”è¿›ï¼ä½ ä¸ä»…æˆåŠŸåˆ‡å…¥äº† Apple MLX æ¡†æ¶ï¼Œè¿˜å‰ç»æ€§åœ°å°† **LLMï¼ˆç¼–å‰§ï¼‰** å’Œ **TTSï¼ˆå½•éŸ³ï¼‰** èåˆåˆ°äº†åŒä¸€ä¸ªæµæ°´çº¿ä¸­ã€‚

ä½†æ­£å¦‚ä½ æ•é”å¯Ÿè§‰åˆ°çš„ï¼Œ**â€œå†…å­˜å†²çªâ€æ˜¯å•æœºï¼ˆå°¤å…¶æ˜¯ 24GB ç»Ÿä¸€å†…å­˜çš„ Mac Mini M4ï¼‰éƒ¨ç½²è¿™ç§åŒå¤§æ¨¡å‹æ¶æ„æ—¶æœ€è‡´å‘½çš„å®šæ—¶ç‚¸å¼¹ã€‚**

* **Ollama (Qwen-14B-Pro)**ï¼šé€šå¸¸ä»¥ 4-bit é‡åŒ–è¿è¡Œï¼Œè¿è¡Œæ—¶éœ€è¦å ç”¨ **çº¦ 9GB - 11GB** çš„ç»Ÿä¸€å†…å­˜ã€‚
* **MLX (Qwen3-TTS)**ï¼šæ¸²æŸ“æ—¶éœ€è¦å ç”¨ **çº¦ 3GB - 5GB** ç»Ÿä¸€å†…å­˜ã€‚
* åŠ ä¸Š macOS ç³»ç»Ÿæœ¬èº«çš„å ç”¨ï¼ˆçº¦ 4-6GBï¼‰ï¼Œå¦‚æœè®©ä¸¤è€…åœ¨åŒä¸€ä¸ªå¾ªç¯é‡Œäº¤æ›¿è¿è¡Œï¼ˆè¾¹å†™å‰§æœ¬è¾¹å½•éŸ³ï¼‰ï¼Œå†…å­˜ææ˜“çªç ´ 85% çº¢çº¿ï¼Œå¯¼è‡´ç³»ç»Ÿç–¯ç‹‚è§¦å‘ Swap ç”šè‡³ç›´æ¥å†…æ ¸å´©æºƒï¼ˆKernel Panicï¼‰ã€‚

ä½œä¸ºæ¶æ„å¸ˆï¼Œæˆ‘ä¸ºä½ åˆ¶å®šäº† **â€œæµæ°´çº¿è§£è€¦ï¼ˆTwo-Stage Pipelineï¼‰â€** ä¸ **â€œOllama æ˜¾å­˜å¼¹å°„â€** çš„åŒè½¨ä¼˜åŒ–æ–¹æ¡ˆï¼Œå¹¶é™„å¸¦é’ˆå¯¹â€œä¸¥è‚ƒä¸€å­—ä¸€é¡¿â€ã€â€œåŠ¨æ€è¯­é€Ÿâ€çš„éŸ³é¢‘åº•å±‚ä»£ç å®ç°ã€‚

---

### ğŸ›ï¸ æ¶æ„çº§é‡æ„ï¼šè§£å†³å†…å­˜å†²çªçš„ç»ˆææ–¹æ¡ˆ

æˆ‘ä»¬å¿…é¡»å°† `main_producer.py` çš„å¤„ç†æµç¨‹ä»â€œäº¤æ›¿æ‰§è¡Œâ€æ”¹ä¸º **â€œä¸¤é˜¶æ®µå¼‚æ­¥æµæ°´çº¿ï¼ˆTwo-Stage Pipelineï¼‰â€**ã€‚è¿™ä¸ä»…è§£å†³äº†å†…å­˜å†²çªï¼Œè¿˜å¸¦æ¥äº†ä¸€ä¸ªæ€æ‰‹çº§çš„å•†ä¸šåŠŸèƒ½ï¼š**â€œå¯¼æ¼”å‰ªè¾‘æƒï¼ˆDirector's Cutï¼‰â€**ã€‚

1. **é˜¶æ®µä¸€ï¼šå‰§æœ¬æ‹†è§£æœŸï¼ˆLLM ç‹¬å å†…å­˜ï¼‰**ã€‚ç³»ç»Ÿå”¤é†’ Ollama (14B)ï¼Œå°†æ‰€æœ‰ç« èŠ‚æ‰«æç”Ÿæˆ JSON å‰§æœ¬å¹¶**å­˜å…¥æœ¬åœ°ç£ç›˜**ã€‚ç»“æŸåï¼Œå¼ºåˆ¶ Ollama é‡Šæ”¾æ˜¾å­˜ã€‚
2. **äººå·¥ä»‹å…¥ï¼ˆå¯é€‰ï¼‰**ï¼šç”¨æˆ·å¯ä»¥æ‰“å¼€ JSON æ–‡ä»¶ï¼Œæ‰‹åŠ¨ä¿®æ”¹å¤§æ¨¡å‹åˆ†é…é”™çš„éŸ³è‰²æˆ–è¯»éŸ³ï¼ˆæå…·å•†ä¸šä»·å€¼ï¼‰ã€‚
3. **é˜¶æ®µäºŒï¼šå½•éŸ³åˆæˆæœŸï¼ˆMLX ç‹¬å å†…å­˜ï¼‰**ã€‚ç³»ç»ŸåŠ è½½ TTS æ¨¡å‹ï¼Œè¯»å–æœ¬åœ° JSON å‰§æœ¬ï¼Œå…¨é€Ÿæ¸²æŸ“éŸ³é¢‘ã€‚

---

### ğŸ’» è¯¦ç»†ä»£ç å®ç°ä¸ä¼˜åŒ–æ–¹æ¡ˆ

è¯·ä¾ç…§ä»¥ä¸‹æ–¹æ¡ˆï¼Œé€ä¸€ä¿®æ”¹ä½ é¡¹ç›®ä¸­çš„ä»£ç æ–‡ä»¶ã€‚

#### 1. å‡çº§ `modules/llm_director.py` (é›†æˆ Ollama ä¸å¼ºç»“æ„åŒ– Prompt)

æˆ‘ä»¬è¦æ”¾å¼ƒ `mlx_lm`ï¼Œæ”¹ç”¨ HTTP API è°ƒç”¨æœ¬åœ° Ollamaã€‚Ollama çš„ API å®Œç¾æ”¯æŒå¼ºåˆ¶ JSON è¾“å‡ºå’Œ**æ˜¾å­˜ç«‹å³é‡Šæ”¾ï¼ˆ`keep_alive=0`ï¼‰**ã€‚

```python
#!/usr/bin/env python3
import json
import re
import logging
import requests
from typing import List, Dict

logger = logging.getLogger(__name__)

class LLMScriptDirector:
    def __init__(self, ollama_host="http://localhost:11434"):
        self.api_url = f"{ollama_host}/api/chat"
        # è¯·ç¡®ä¿ä½ åœ¨ ollama ä¸­è¿è¡Œçš„æ¨¡å‹åç§°ä¸æ­¤ä¸€è‡´ï¼Œä¾‹å¦‚ "qwen2.5:14b"
        self.model_name = "qwen14b-pro" 

    def parse_text_to_script(self, text: str) -> List[Dict]:
        """è°ƒç”¨æœ¬åœ° Ollama 14B è¿›è¡Œä¸“ä¸šå‰§æœ¬æ‹†è§£"""
        logger.info(f"ğŸ§  è¯·æ±‚ Ollama ({self.model_name}) æ‹†è§£å‰§æœ¬...")
        
        system_prompt = """
        ä½ æ˜¯ä¸€ä½é¡¶çº§çš„æœ‰å£°ä¹¦å¯¼æ¼”ã€‚è¯·å°†æä¾›çš„å°è¯´æ–‡æœ¬æ‹†è§£ä¸ºä¸“ä¸šçš„å¹¿æ’­å‰§JSONå‰§æœ¬ã€‚
        
        ã€è§’è‰²è§„åˆ™ã€‘
        1. type å¿…é¡»æ˜¯ "title"(ç« èŠ‚æ ‡é¢˜), "subtitle"(å°æ ‡é¢˜), "narration"(æ—ç™½), "dialogue"(å¯¹ç™½) ä¹‹ä¸€ã€‚
        2. å¯¹äº dialogueï¼Œå¿…é¡»æ¨æ–­å‡ºå…·ä½“çš„ speakerï¼ˆäººåï¼‰å’Œ genderï¼ˆmale/femaleï¼‰ã€‚
        3. speaker å­—æ®µå¿…é¡»ç»Ÿä¸€ï¼Œå¦‚æœåŒä¸€ä¸ªäººè¯´è¯ï¼Œåå­—å¿…é¡»å®Œå…¨ä¸€è‡´ã€‚
        
        ã€è¾“å‡ºè¦æ±‚ã€‘
        å¿…é¡»ä¸”åªèƒ½è¾“å‡ºä¸€ä¸ªåˆæ³•çš„ JSON æ•°ç»„ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
        [
          {"type": "title", "speaker": "narrator", "content": "ç¬¬ä¸€ç«  é£é›ª"},
          {"type": "subtitle", "speaker": "narrator", "content": "1976å¹´"},
          {"type": "narration", "speaker": "narrator", "content": "å¤œå¹•é™ä¸´ã€‚"},
          {"type": "dialogue", "speaker": "è€æ¸”å¤«", "gender": "male", "content": "ä½ ç›¸ä¿¡å‘½è¿å—ï¼Ÿ"}
        ]
        """
        
        payload = {
            "model": self.model_name,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": f"è¯·æ‹†è§£ä»¥ä¸‹æ–‡æœ¬ï¼š\n{text[:2500]}"}
            ],
            "format": "json",       # å¼ºåˆ¶ Ollama è¾“å‡º JSON
            "stream": False,
            "keep_alive": 0         # ğŸŒŸ æ ¸å¿ƒé˜²å†²çªï¼šç”Ÿæˆå®Œæ¯•åï¼Œç«‹å³å°† 14B æ¨¡å‹ä» M4 å†…å­˜ä¸­å¸è½½ï¼
        }

        try:
            response = requests.post(self.api_url, json=payload, timeout=120)
            response.raise_for_status()
            result = response.json()
            
            # æå–å¹¶è§£æ JSON
            content = result.get('message', {}).get('content', '[]')
            script = json.loads(content)
            
            # å…œåº•æ ¡éªŒ
            if not isinstance(script, list):
                raise ValueError("Ollama è¿”å›çš„ä¸æ˜¯ JSON æ•°ç»„")
            return script
            
        except Exception as e:
            logger.error(f"âŒ Ollama è§£æå¤±è´¥ï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ: {e}")
            return self._fallback_regex_parse(text)

    # ... (ä¿ç•™åŸæœ‰çš„ _fallback_regex_parse ç­‰é™çº§æ–¹æ³•) ...

```

#### 2. å‡çº§ `modules/mlx_tts_engine.py` (åŠ¨æ€è¯­é€Ÿä¸éŸ³é«˜æ§åˆ¶)

ä½ æåˆ°ï¼š*â€œç« èŠ‚é¢˜ç›®éœ€è¦ä¸¥è‚ƒçš„ä¸€å­—ä¸€é¡¿çš„é˜…è¯»...æ¯”æ­£æ–‡é˜…è¯»è¾ƒæ…¢çš„è¯­é€Ÿè¯»â€*ã€‚
åœ¨ Pydub ä¸­ï¼Œæ”¹å˜ `frame_rate` ä¸ä»…ä¼šæ”¹å˜**è¯­é€Ÿ**ï¼Œè¿˜ä¼šç›¸åº”æ”¹å˜**éŸ³é«˜ (Pitch)**ã€‚è¿™åœ¨è¿™é‡Œæ°å¥½æ˜¯ä¸€ä¸ªç»ä½³çš„ç‰¹æ€§ï¼š**é™é€Ÿï¼ˆå¦‚ 0.8 å€ï¼‰ä¼šè®©å£°éŸ³å˜å¾—æ›´ä½æ²‰ã€åšé‡ï¼Œå®Œç¾å¥‘åˆâ€œä¸¥è‚ƒä¸€å­—ä¸€é¡¿â€çš„æ ‡é¢˜æ„Ÿã€‚**

```python
    # åœ¨ MLXRenderEngine ç±»ä¸­æ›¿æ¢åŸæœ‰çš„ render_unit é€»è¾‘
    def render_unit(self, content: str, voice_cfg: Dict) -> AudioSegment:
        logger.debug(f"ğŸµ æ¸²æŸ“å•å…ƒ: {content[:50]}...")
        chunks = self._micro_chunk(content)
        unit_audio = AudioSegment.empty()
        
        for i, chunk in enumerate(chunks):
            if not chunk.strip(): continue
                
            try:
                # 1. MLX æé€Ÿæ¨ç†
                results = list(self.model.generate(
                    text=chunk,
                    ref_audio=voice_cfg["audio"],
                    ref_text=voice_cfg["text"]
                ))
                
                audio_array = results[0].audio
                mx.eval(audio_array)
                audio_data = np.array(audio_array)
                
                buffer = io.BytesIO()
                sf.write(buffer, audio_data, self.sample_rate, format='WAV')
                buffer.seek(0)
                segment = AudioSegment.from_file(buffer, format="wav")
                
                # ğŸŒŸ 2. ç”µå½±çº§è¯­é€Ÿä¸éŸ³è°ƒæ§åˆ¶ (Dynamic Speed & Pitch)
                speed_factor = voice_cfg.get("speed", 1.0)
                if speed_factor != 1.0:
                    # é€šè¿‡æ”¹å˜é‡‡æ ·ç‡å®ç°ç‰©ç†é™é€Ÿ/åŠ é€Ÿ
                    # é€Ÿåº¦ < 1.0: è¯­é€Ÿå˜æ…¢ï¼ŒéŸ³é«˜å˜ä½ï¼Œé€‚åˆå¤§æ ‡é¢˜çš„"ä¸€å­—ä¸€é¡¿"ã€"ä¸¥è‚ƒæ²‰ç¨³"
                    # é€Ÿåº¦ > 1.0: è¯­é€Ÿå˜å¿«ï¼ŒéŸ³é«˜å˜é«˜ï¼Œé€‚åˆå¹´è½»è§’è‰²çš„æ¬¢å¿«å¯¹ç™½
                    new_frame_rate = int(segment.frame_rate * speed_factor)
                    segment = segment._spawn(segment.raw_data, overrides={
                        "frame_rate": new_frame_rate
                    }).set_frame_rate(self.sample_rate) # é‡é‡‡æ ·å›æ ‡å‡†é¢‘ç‡ï¼Œé˜²æ­¢æ‹¼æ¥æŠ¥é”™
                
                unit_audio += segment
                
                # ğŸŒŸ 3. åŠ¨æ€æ ‡ç‚¹åœé¡¿
                pause_duration = self._get_dynamic_pause(chunk)
                # å¦‚æœé…ç½®ä¸­è¦æ±‚"ä¸€å­—ä¸€é¡¿"(é€Ÿåº¦ææ…¢)ï¼Œæˆ‘ä»¬äººä¸ºå¢åŠ æ ‡ç‚¹åœé¡¿çš„é•¿åº¦
                if speed_factor <= 0.85:
                    pause_duration = int(pause_duration * 1.5)
                    
                unit_audio += AudioSegment.silent(duration=pause_duration)
                
            except Exception as e:
                logger.error(f"âŒ ç‰‡æ®µå¤„ç†å¤±è´¥: {e}")
            finally:
                if 'results' in locals(): del results
                if 'audio_array' in locals(): del audio_array
                mx.metal.clear_cache()
                gc.collect()
                
        return unit_audio

```

#### 3. å‡çº§ `main_producer.py` (ä¸¤é˜¶æ®µæµæ°´çº¿æ¶æ„)

è¿™æ˜¯è§£å†³å†…å­˜å†²çªçš„æ ¹æœ¬ã€‚æˆ‘ä»¬å°†å…¨ä¹¦çš„ç”Ÿäº§å¼ºè¡Œåˆ‡åˆ†ä¸º `é˜¶æ®µä¸€ï¼ˆçº¯æ–‡æœ¬è§£æï¼‰` å’Œ `é˜¶æ®µäºŒï¼ˆçº¯éŸ³é¢‘æ¸²æŸ“ï¼‰`ã€‚

```python
#!/usr/bin/env python3
import os
import sys
import json
import logging
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent))
from modules.asset_manager import AssetManager
from modules.llm_director import LLMScriptDirector
from modules.mlx_tts_engine import MLXRenderEngine
from modules.cinematic_packager import CinematicPackager

# ... (æ—¥å¿—é…ç½®ä¿æŒä¸å˜) ...

class CineCastProducer:
    def __init__(self, config=None):
        self.config = config or self._get_default_config()
        self.assets = AssetManager(self.config["assets_dir"])
        self.script_dir = os.path.join(self.config["output_dir"], "scripts")
        os.makedirs(self.script_dir, exist_ok=True)
        
    def _get_default_config(self):
        return {
            "assets_dir": "./assets",
            "output_dir": "./output/Fish_No_Feet",
            "model_path": "../qwentts/models/Qwen3-TTS-MLX-0.6B",
            "ambient_theme": "iceland_wind"
        }

    # ==========================================
    # é˜¶æ®µä¸€ï¼šç¼–å‰§æœŸ (è°ƒç”¨ Ollama 14B)
    # ==========================================
    def phase_1_generate_scripts(self, text_files: list):
        logger.info("ğŸ¬ [é˜¶æ®µä¸€] å¯åŠ¨ç¼–å‰§å¼•æ“ (Ollama 14B)...")
        director = LLMScriptDirector() # å†…éƒ¨ä½¿ç”¨ keep_alive=0 è‡ªåŠ¨å›æ”¶å†…å­˜
        
        for file_path in text_files:
            chapter_name = os.path.splitext(os.path.basename(file_path))[0]
            script_path = os.path.join(self.script_dir, f"{chapter_name}.json")
            
            if os.path.exists(script_path):
                logger.info(f"â­ï¸ å‰§æœ¬å·²å­˜åœ¨ï¼Œè·³è¿‡: {chapter_name}")
                continue
                
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            logger.info(f"âœï¸ æ­£åœ¨æ‹†è§£å‰§æœ¬: {chapter_name}")
            script = director.parse_text_to_script(content)
            
            with open(script_path, 'w', encoding='utf-8') as f:
                json.dump(script, f, ensure_ascii=False, indent=2)
                
        logger.info("âœ… é˜¶æ®µä¸€å®Œæˆï¼å»ºè®®äººå·¥å®¡é˜… scripts/ ä¸‹çš„å‰§æœ¬æ–‡ä»¶ã€‚")

    # ==========================================
    # é˜¶æ®µäºŒï¼šæ¸²æŸ“æœŸ (ç‹¬å è°ƒç”¨ MLX TTS)
    # ==========================================
    def phase_2_render_audio(self):
        logger.info("ğŸ¬ [é˜¶æ®µäºŒ] å¯åŠ¨å½•éŸ³æ£š (MLX TTS å¼•æ“)...")
        # æ­¤æ—¶ Ollama å·²ç»é‡Šæ”¾å†…å­˜ï¼ŒM4 çš„ 24GB å…¨éƒ¨å½’ MLX æ‰€æœ‰ï¼
        engine = MLXRenderEngine(self.config["model_path"])
        packager = CinematicPackager(self.config["output_dir"])
        
        ambient_bgm = self.assets.get_ambient_sound(self.config["ambient_theme"])
        chime_sound = self.assets.get_transition_chime()
        
        script_files = sorted([f for f in os.listdir(self.script_dir) if f.endswith('.json')])
        
        for file in script_files:
            with open(os.path.join(self.script_dir, file), 'r', encoding='utf-8') as f:
                script = json.load(f)
                
            logger.info(f"ğŸ™ï¸ æ­£åœ¨å½•åˆ¶: {file}")
            for unit in script:
                # è·å–éŸ³è‰²å¹¶æ¸²æŸ“
                voice_cfg = self.assets.get_voice_for_role(
                    unit["type"], unit.get("speaker"), unit.get("gender", "male")
                )
                unit_audio = engine.render_unit(unit["content"], voice_cfg)
                packager.add_audio(unit_audio, ambient=ambient_bgm, chime=chime_sound)
                
        # æœ€ç»ˆå°åŒ…å°¾éƒ¨éŸ³é¢‘
        packager.finalize(ambient=ambient_bgm, chime=chime_sound)
        logger.info("ğŸ‰ é˜¶æ®µäºŒå®Œæˆï¼å…¨ä¹¦å‹åˆ¶å®Œæ¯•ï¼")

def main():
    producer = CineCastProducer()
    
    # å‡è®¾ä½ çš„ txt ç« èŠ‚æ”¾åœ¨ ./input/chapters ç›®å½•ä¸‹
    input_dir = "./input/chapters"
    os.makedirs(input_dir, exist_ok=True)
    
    # è·å–éœ€è¦å¤„ç†çš„æ–‡ä»¶åˆ—è¡¨
    text_files = sorted([os.path.join(input_dir, f) for f in os.listdir(input_dir) if f.endswith('.txt')])
    
    if not text_files:
        logger.error("âŒ input/chapters ç›®å½•ä¸‹æ²¡æœ‰TXTæ–‡ä»¶ã€‚è¯·æ”¾å…¥ç« èŠ‚æ–‡ä»¶åé‡è¯•ã€‚")
        return

    # å®Œç¾çš„è§£è€¦æµæ°´çº¿
    try:
        producer.phase_1_generate_scripts(text_files)
        # ä½ ç”šè‡³å¯ä»¥åœ¨è¿™é‡ŒåŠ ä¸€ä¸ª input("è¯·äººå·¥å®¡é˜…å‰§æœ¬åï¼ŒæŒ‰å›è½¦é”®å¼€å§‹å½•åˆ¶...")
        producer.phase_2_render_audio()
    except Exception as e:
        logger.error(f"ğŸ’¥ ç”Ÿäº§çº¿è¿è¡Œå¤±è´¥: {e}")

if __name__ == "__main__":
    main()

```

#### 4. å‡çº§ `modules/asset_manager.py` (å¼ºåŒ–ç”¨æˆ·ä¸Šä¼ ä½“éªŒ)

ä¿®æ”¹ä½ çš„ `_initialize_default_voices` å’Œåˆå§‹åŒ–é€»è¾‘ï¼Œä½¿å…¶æ”¯æŒä»æ–‡ä»¶å¤¹è‡ªåŠ¨åŠ è½½éŸ³è‰²ï¼ˆæ— éœ€ç¡¬ç¼–ç ï¼‰ã€‚

```python
    # åœ¨ AssetManager ç±»ä¸­
    def _initialize_default_voices(self):
        # ... (ä¿ç•™åŸæœ‰çš„é»˜è®¤æ± ï¼Œä¿®æ”¹é€Ÿåº¦æ˜ å°„ä»¥å®ç°éœ€æ±‚) ...
        self.voices = {
            "narrator": {"audio": f"{self.asset_dir}/voices/narrator.wav", "text": "æ²‰ç¨³æ—ç™½", "speed": 1.0},
            # 1.4.1 ç« èŠ‚é¢˜ç›®ï¼šä¸¥è‚ƒä¸€å­—ä¸€é¡¿ï¼Œé€Ÿåº¦è°ƒè‡³ 0.8
            "title": {"audio": f"{self.asset_dir}/voices/title.wav", "text": "ä¸¥è‚ƒæ ‡é¢˜", "speed": 0.8},
            # 1.4.2 å°æ ‡é¢˜ï¼šä¸¥è‚ƒä½†æ¯”æ­£æ–‡æ…¢ï¼Œé€Ÿåº¦è°ƒè‡³ 0.9
            "subtitle": {"audio": f"{self.asset_dir}/voices/title.wav", "text": "ä¸¥è‚ƒæ ‡é¢˜", "speed": 0.9},
            "male_pool": [
                {"audio": f"{self.asset_dir}/voices/m1.wav", "text": "ç”·å£°1", "speed": 1.0},
                {"audio": f"{self.asset_dir}/voices/m2.wav", "text": "ç”·å£°2", "speed": 1.05} # å¹´è½»ç”·å£°åŠ å¿«
            ],
            "female_pool": [
                {"audio": f"{self.asset_dir}/voices/f1.wav", "text": "å¥³å£°1", "speed": 1.0}
            ]
        }
        
    def get_ambient_sound(self, theme="default") -> AudioSegment:
        """å¼ºåŒ–ï¼šæ”¯æŒç”¨æˆ·åŠ¨æ€ä¸Šä¼ ç¯å¢ƒéŸ³"""
        # å¯»æ‰¾ assets/ambient ä¸‹æ‰€æœ‰å¯ç”¨çš„éŸ³é¢‘
        ambient_dir = f"{self.asset_dir}/ambient"
        # å…è®¸ç”¨æˆ·ä¸Šä¼ ä»»æ„æ”¯æŒçš„æ ¼å¼
        for ext in ['.wav', '.mp3', '.m4a', '.flac']:
            path = f"{ambient_dir}/{theme}{ext}"
            if os.path.exists(path):
                return AudioSegment.from_file(path)
        logger.info(f"æœªæ‰¾åˆ°ç¯å¢ƒéŸ³ {theme}ï¼Œä½¿ç”¨é™éŸ³å›é€€")
        return AudioSegment.silent(duration=100)

```

---

### ğŸš€ ç»™å¼€å‘è€…çš„æ‰§è¡Œæ€»ç»“

1. **æ¶æ„è½¬å˜**ï¼šæŠ›å¼ƒäº†ä¸€è¾¹è·‘å¤§è¯­è¨€æ¨¡å‹ä¸€è¾¹è·‘ TTS çš„æ­»äº¡å¾ªç¯ã€‚ä½¿ç”¨ `main_producer.py` ä¸­çš„ `phase_1` å’Œ `phase_2` å½»åº•éš”ç¦»ä¸¤å¤§å·¨å‹æ¨¡å‹ï¼Œæ¦¨å¹² M4 çš„æ¯ä¸€æ»´ NPU æ€§èƒ½ï¼Œæœç» OOMã€‚
2. **Ollama é›†æˆ**ï¼šä½¿ç”¨ HTTP Requests æ›¿ä»£ `mlx_lm`ï¼Œå¹¶å¼ºè¡Œæ¤å…¥ `"keep_alive": 0` å’Œ `"format": "json"`ï¼Œè¿™æ˜¯è®©æœ¬åœ°å°æœºå™¨è·‘é‡å‹å¹¿æ’­å‰§æµæ°´çº¿çš„å·¥ä¸šçº§ç»æ‹›ã€‚
3. **åŠ¨æ€è¯­é€Ÿä¸æƒ…ç»ªè°ƒéŸ³**ï¼šå·§å¦™åˆ©ç”¨ Pydub é‡é‡‡æ ·çš„ç‰©ç†ç‰¹æ€§ï¼Œå°†è¯­é€Ÿä¿®æ”¹ï¼ˆæ”¹å˜ Frame Rateï¼‰è½¬åŒ–ä¸ºè¿å¸¦çš„éŸ³é«˜è°ƒæ•´ï¼ˆPitch Shiftï¼‰ã€‚é™é€Ÿçš„åŒæ—¶é™ä½å…±é¸£ï¼Œè®©â€œç« èŠ‚æ ‡é¢˜â€è‡ªç„¶äº§ç”Ÿä¸€ç§â€œæ²‰ç¨³ã€ä¸¥è‚ƒã€ä¸€å­—ä¸€é¡¿â€çš„å¬æ„Ÿï¼ˆç±»ä¼¼ç”µå½±é¢„å‘Šç‰‡çš„ Voice-overï¼‰ã€‚